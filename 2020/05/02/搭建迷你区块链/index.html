<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>搭建迷你区块链 | 饼干🍪</title><meta name="description" content="搭建迷你区块链"><meta name="keywords" content="区块链"><meta name="author" content="Huang Mi Gao"><meta name="copyright" content="Huang Mi Gao"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2020/05/02/%E6%90%AD%E5%BB%BA%E8%BF%B7%E4%BD%A0%E5%8C%BA%E5%9D%97%E9%93%BE/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="搭建迷你区块链"><meta name="twitter:description" content="搭建迷你区块链"><meta name="twitter:image" content="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588397534324&amp;di=6c1ae2cd4ad0063e9ebfe34a2babf934&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.91zhuti.com%2Fuploads%2Fallimg%2F140517%2F10-14051F95044.jpg"><meta property="og:type" content="article"><meta property="og:title" content="搭建迷你区块链"><meta property="og:url" content="http://yoursite.com/2020/05/02/%E6%90%AD%E5%BB%BA%E8%BF%B7%E4%BD%A0%E5%8C%BA%E5%9D%97%E9%93%BE/"><meta property="og:site_name" content="饼干🍪"><meta property="og:description" content="搭建迷你区块链"><meta property="og:image" content="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588397534324&amp;di=6c1ae2cd4ad0063e9ebfe34a2babf934&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.91zhuti.com%2Fuploads%2Fallimg%2F140517%2F10-14051F95044.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="实验：EFS的加密、解密与破解" href="http://yoursite.com/2020/05/08/%E5%AE%9E%E9%AA%8C%EF%BC%9AEFS%E7%9A%84%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86%E4%B8%8E%E7%A0%B4%E8%A7%A3/"><link rel="next" title="Django-url跳转漏洞实验剖析" href="http://yoursite.com/2020/04/30/django-url%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cc131bc17833a8d2789cd65c6e42de3f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验步骤⼀"><span class="toc-number">1.</span> <span class="toc-text">实验步骤⼀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验步骤⼆"><span class="toc-number">2.</span> <span class="toc-text">实验步骤⼆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验步骤三"><span class="toc-number">3.</span> <span class="toc-text">实验步骤三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实验步骤四"><span class="toc-number">4.</span> <span class="toc-text">实验步骤四</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588397534324&amp;di=6c1ae2cd4ad0063e9ebfe34a2babf934&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.91zhuti.com%2Fuploads%2Fallimg%2F140517%2F10-14051F95044.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">饼干🍪</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">我年轻的时候曾是一个诗人。</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 类别</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 工具</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-archive"></i><span> 相册</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">搭建迷你区块链</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-02<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-02</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><ol>
<li><p>⽐特币⽹络 </p>
<p>⾸先，⽐特币⽹络中的节点主要有四⼤功能：钱 包、挖矿、区块链数据库、⽹络路由。每个节点都会 具备路由功能，但其他功能不⼀定都具备，不同类型 的节点可能只包含部分功能，⼀般只有⽐特币核⼼(bit coin core)节点才会包含所有四⼤功能。</p>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502101616.png" class="lozad"></p>
</li>
</ol>
<p>​     所有节点都会参与校验和⼴播交易及区块信息， 且会发现和维持与其他节点的连接。有些节点会包含 完整的区块链数据库，包括所有交易数据，这种节点 也称为全节点(Full Node)。另外⼀些节点只存储了区 块链数据库的⼀部分，⼀般只存储区块头⽽不存储交 易数据，它们会通过“简化交易验证(SPV)”的⽅式完成 交易校验，这样的节点也称为 SPV节点或轻节点(Light weight Node)。钱包⼀般是 PC 或⼿机客户端的功 能，⽤户通过钱包查看⾃⼰的账户⾦额、管理钱包地 址和私钥、发起交易等。除了⽐特币核⼼钱包是全节 点之外，⼤部分钱包都是轻节点。挖矿节点则通过解 决⼯作量证明(PoW)算法问题，与其他挖矿节点相互竞 争创建新区块。有些挖矿节点同时也是全节点，即也 存储了完整的区块链数据库，这种节点⼀般都是独⽴ 矿⼯(Solo Miner)。还有⼀些挖矿节点不是独⽴挖矿 的，⽽是和其他节点⼀起连接到矿池，参与集体挖 矿，这种节点⼀般也称为矿池矿⼯(Pool Miner)。这会 形成⼀个局部的集中式矿池⽹络，中⼼节点是⼀个矿 池服务器，其他挖矿节点全部连接到矿池服务器。矿 池矿⼯和矿池服务器之间的通信也不是采⽤标准的⽐ 特币协议，⽽是使⽤矿池挖矿协议，⽽矿池服务器作 为⼀个全节点再与其他⽐特币节点使⽤主⽹络的⽐特 币协议进⾏通信。 在整个⽐特币⽹络中，除了不同节点间使⽤⽐特 币协议作为通信协议的主⽹络，也存在很多扩展⽹ 络，包括上⾯提到的矿池⽹络。不同的矿池⽹络可能 还会使⽤不同的矿池挖矿协议，⽬前主流的具体矿池 协议应该是 Stratum协议，该协议除了⽀持挖矿节 点，也⽀持瘦客户端钱包。⼀个包含了⽐特币协议主 ⽹络各种节点和 Stratum ⽹络，以及其他矿池⽹络的 扩展⽐特币⽹络⼤概如下图所示：</p>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502101704.png" class="lozad"></p>
<p>另外，挖矿这块还有特殊需求。我们知道，矿⼯ 创建新区块后，是需要⼴播给全⽹所有节点的，当全 ⽹都接受了该区块，给矿⼯的挖矿奖励才算是有效 的，这之后才好开始下⼀个区块 Hash 的计算。所以 矿⼯必须最⼤限度缩短新区块的⼴播和下⼀个区块 Ha sh 计算之间的时间。如果矿⼯之间传播区块只采⽤上 图所示的⽐特币协议⽹络，那⽆疑会有很⾼的⽹络延 迟，所以，需要⼀个专⻔的传播⽹络⽤来加快新区块 在矿⼯之间的同步传播，这个专⻔⽹络也叫⽐特币传 播⽹络或⽐特币中继⽹络(Bitcoin Relay Network)。 2. Kademlia（简称Kad）算法 ⽐特币主⽹的P2P⽹络是⽆结构的，就是⼀个随机 ⽹络，不能将所有⼏点按照某种结构进⾏有序组织， ⽐如形成⼀个环状⽹络或树状⽹络。所以引⼊结构化P 2P⽹络的概念。结构化P2P⽹络普遍都是基于DHT(Di stributed Hash Table，分布式哈希表)的算法思想， 主要想解决如何在分布式环境下快速⽽⼜准确地路 由、定位数据的问题。具体的实现⽅案有Chord、Past ry、CAN、Kademlia等算法。本次实验实现的是常⻅ ⽽巧妙的分布式技术，Kademlia算法。 试想⼀下，⼀所1000⼈的学校，现在学校突然决 定拆掉图书馆（不设⽴中⼼化的服务器），将图书馆 ⾥所有的书都分发到每位学⽣⼿上（所有的⽂件分散 存储在各个节点上）。即是所有的学⽣，共同组成了 ⼀个分布式的图书馆。</p>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502101803.png" class="lozad"></p>
<p>接下来，让我们来看看Kademlia算法如何巧妙地 解决这些问题。 2) 节点的要素 ⾸先我们来看看每个同学（节点）都有哪些属 性： Ø 学号（Node ID，2进制，160位） Ø ⼿机号码（节点的IP地址及端⼝） 每个同学会维护以下内容： Ø 从图书馆分发下来的书本（被分配到需要存储 的内容），每本书当然都有书名和书本内容（内容以< key, value>对的形式存储，可以理解为⽂件名和⽂件 内容）； Ø ⼀个通讯录，包含⼀⼩部分其他同学的学号和 ⼿机号，通讯录按学号分层（⼀个路由表，称为“k-bu cket”，按Node ID分层，记录有限个数的其他节点的I D和IP地址及端⼝）。 根据上⾯那个类⽐，可以看看这个表格：<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502101842.png" class="lozad"></p>
<p>注：关于为什么不是每个同学都有全量通讯录 （每个节点都维护全量路由信息）：其⼀，分布式系 统中节点的进⼊和退出是相当频繁的，每次有变动时 都全⽹⼴播通讯录更新，通讯量会很⼤；其⼆，⼀旦任意⼀个同学被坏⼈绑架了（节点被⿊客攻破），则 坏⼈⻢上就拥有了所有⼈的⼿机号码，这并不安全。 3) ⽂件的存储及查找 原来收藏在图书馆⾥，按索引号码得整整⻬⻬的 书，以⼀种什么样的⽅式分发到同学们⼿⾥呢？⼤致 的原则，包括：1）书本能够⽐较均衡地分布在同学们 的⼿⾥，不会出现部分同学⼿⾥书特别多、⽽⼤部分 同学连⼀本书都没有的情况；2）同学想找⼀本特定的 书的时候，能够⼀种相对简单的索引⽅式找到这本 书。 Kademlia作了下⾯这种安排： 假设《分布式算法》这本书的书名的hash值是 00 010000，那么这本书就会被要求存在学号为0001000 0的同学⼿上。（这要求hash算法的值域与node ID的 值域⼀致。Kademlia的Node ID是160位2进制。这⾥ 的示例对Node ID进⾏了简略） 但还得考虑到会有同学缺勤。万⼀00010000今天 没来上学（节点没有上线或彻底退出⽹络），那《分 布式算法》这本书岂不是谁都拿不到了？那算法要求 这本书不能只存在⼀个同学⼿上，⽽是被要求同时存 储在学号最接近00010000的k位同学⼿上，即000100 01、00010010、00010011…等同学⼿上都会有这本 书。 同样地，当你需要找《分布式算法》这本书时， 将书名hash⼀下，得到 00010000，这个便是索书 号，你就知道该找哪（⼏）位同学了。剩下的问题， 就是找到这（⼏）位同学的⼿机号。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502101926.png" class="lozad"></p>
<p>4) 节点的异或距离 由于你⼿上只有⼀部分同学的通讯录，你很可能 并没有00010000的⼿机号（IP地址）。那如何联系上 ⽬标同学呢？<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502101949.png" class="lozad"></p>
<p>⼀个可⾏的思路就是在你的通讯录⾥找到⼀位拥 有⽬标同学的联系⽅式的同学。前⾯提到，每位同学 ⼿上的通讯录都是按距离分层的。算法的设计是，如 果⼀个同学离你越近，你⼿上的通讯录⾥存有ta的⼿机 号码的概率越⼤。⽽算法的核⼼的思路就可以是：当 你知道⽬标同学Z与你之间的距离，你可以在你的通讯 录上先找到⼀个你认为与同学Z最相近的同学B，请同 学B再进⼀步去查找同学Z的⼿机号。 上⽂提到的距离，是学号（Node ID）之间的异或 距离(XOR distance）。异或是针对yes/no或者⼆进制 的运算。 举两个例⼦： Ø 01010000与01010010距离（即是2个ID的异或 值）为00000010（换算为⼗进制即为2）； Ø 01000000与00000001距离为01000001（换算 为⼗进制即为26+1，即65），如此类推。 那通讯录是如何按距离分层呢？下⾯的示例会告 诉你，按异或距离分层，基本上可以理解为按位数分 层。设想以下情景： 以0000110为基础节点，如果⼀个节点的ID，前⾯ 所有位数都与它相同，只有最后1位不同，这样的节点 只有1个——0000111，与基础节点的异或值为000000 1，即距离为1；对于0000110⽽⾔，这样的节点归为“k -bucket 1”； 如果⼀个节点的ID，前⾯所有位数相同，从倒数 第2位开始不同，这样的节点只有2个：0000101、000 0100，与基础节点的异或值为0000011和0000010， 即距离范围为3和2；对于0000110⽽⾔，这样的节点 归为“k-bucket 2”； …… 如果⼀个节点的ID，前⾯所有位数相同，从倒数 第n位开始不同，这样的节点只有2(i-1)个，与基础节 点的距离范围为[2(i-1), 2i）；对于0000110⽽⾔，这 样的节点归为“k-bucket i”；<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102024.png" class="lozad"></p>
<p>对上⾯描述的另⼀种理解⽅式：如果将整个⽹络 的节点梳理为⼀个按节点ID排列的⼆叉树，树最末端 的每个叶⼦便是⼀个节点，则下图就⽐较直观的展现 出，节点之间的距离的关系。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102049.png" class="lozad"></p>
<p>回到我们的类⽐。每个同学只维护⼀部分的通讯 录，这个通讯录按照距离分层（可以理解为按学号与 ⾃⼰的学号从第⼏位开始不同⽽分层），即k-bucket1, k-bucket 2, k-bucket 3…虽然每个k-bucket中实际 存在的同学⼈数逐渐增多，但每个同学在它⾃⼰的每 个k-bucket中只记录k位同学的⼿机号（k个节点的地 址与端⼝，这⾥的k是⼀个可调节的常量参数）。 由于学号（节点的ID）有160位，所以每个同学的 通讯录中共分160层（节点共有160个k-bucket）。整 个⽹络最多可以容纳2^160个同学（节点），但是每个  同学（节点）最多只维护160 * k ⾏通讯录（其他节点 的地址与端⼝）。 5) 节点定位 我们现在来阐述⼀个完整的索书流程。 A同学（学号00000110）想找《分布式算法》，A ⾸先需要计算书名的哈希值，hash(《分布式算法》) = 00010000。那么A就知道ta需要找到00010000号同学 （命名为Z同学）或学号与Z邻近的同学。 Z的学号00010000与⾃⼰的异或距离为 0001011 0，距离范围在[24, 25)，所以这个Z同学可能在k-buc ket 5中（或者说，Z同学的学号与A同学的学号从第5 位开始不同，所以Z同学可能在k-bucket 5中）。 然后A同学看看⾃⼰的k-bucket 5有没有Z同学： Ø 如果有，那就直接联系Z同学要书； Ø 如果没有，在k-bucket 5⾥随便找⼀个B同学 （注意任意B同学，它的学号第5位肯定与Z相同，即它 与Z同学的距离会⼩于24，相当于⽐Z、A之间的距离 缩短了⼀半以上），请求B同学在它⾃⼰的通讯录⾥按 同样的查找⽅式找⼀下Z同学： ² 如果B知道Z同学，那就把Z同学的⼿机号（IP A ddress）告诉A； ² 如果B也不知道Z同学，那B按同样的搜索⽅法， 可以在⾃⼰的通讯录⾥找到⼀个离Z更近的C同学 （Z、C之间距离⼩于23），把C同学推荐给A；A同学 请求C同学进⾏下⼀步查找。 <img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102131.png" class="lozad"></p>
<p>Kademlia的这种查询机制，有点像是将⼀张纸不 断地对折来收缩搜索范围，保证对于任意n个学⽣，最 多只需要查询log2(n)次，即可找到获得⽬标同学的联 系⽅式（即在对于任意⼀个有[2 , 2 )个节点的⽹ 络，最多只需要n步搜索即可找到⽬标节点）。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102203.png" class="lozad"></p>
<p>以上便是Kademlia算法的基本原理。以下再简要 介绍协议中的技术细节。 6) 算法的三个参数：keyspace，k和α a) keyspace Ø 即ID有多少位 Ø 决定每个节点的通讯录有⼏层 b) k Ø 每个⼀层k-bucket⾥装k个node的信息，即 Ø 每次查找node时，返回k个node的信息 Ø 对于某个特定的data，离其key最近的k个节点 被会要求存储这个data c) α Ø 每次向其他node请求查找某个node时，会向α 个node发出请求 7) 节点的指令 Kademlia算法中，每个节点只有4个指令： Ø PING：测试⼀个节点是否在线 Ø STORE：要求⼀个节点存储⼀份数据 Ø FIND_NODE：根据节点ID查找⼀个节点 Ø FIND_VALUE：根据KEY查找⼀个数据，实则 上跟FIND_NODE⾮常类似 8) k-bucket的维护及更新机制 a) 每个bucket⾥的节点都按最后⼀次接触的时间 倒序排列 b) 每次执⾏四个指令中的任意⼀个都会触发更新 c) 当⼀个节点与⾃⼰接触时，检查它是否在K-bu cket中 Ø 如果在，那么将它挪到k-bucket列表的最底 （最新） Ø 如果不在，PING⼀下列表最上⾯（最旧）的⼀ 个节点 ² 如果PING通了，将旧节点挪到列表最底，并丢 弃新节点 ² 如果PING不通，删除旧节点，并将新节点加⼊ 列表 该机制保证了任意节点加⼊和离开都不影响整体 ⽹络。 9) 总结 Kademlia是分布式哈希表（Distributed Hash Ta ble, DHT）的⼀种。⽽DHT是⼀类去中⼼化的分布式 系统。在这类系统中，每个节点（node）分别维护⼀ 部分的存储内容以及其他节点的路由/地址，使得⽹络 中任何参与者（即节点）发⽣变更（进⼊/退出）时， 对整个⽹络造成的影响最⼩。DHT可以⽤于构建更复 杂的应⽤，包括分布式⽂件系统、点对点技术⽂件分 享系统、合作的⽹⻚⾼速缓存、域名系统以及实时通 信等。 Kademlia算法在2002年由Petar Maymounkov 和 David Mazières 所设计，以异或距离来对哈希表进⾏ 分层是其特点。Kademlia后来被eMule、BitTorrent等 P2P软件采⽤作为底层算法。Kademlia可以作为信息 安全技术的奠基之⼀。 Kademlia的优点在于： Ø 对于任意⼀个有[ 2(n−1) ,2�)个节点的⽹络， 最多只需要n步搜索即可找到⽬标节点； Ø K-bucket的更新机制⼀定程度上保持了⽹络的 活性和安全性。 实验⽬的 实现迷你区块链的P2P⽹络。 </p>
<p>实验环境 </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器：Ubuntu 16.04 </span><br><span class="line">IP地址：随机分配 </span><br><span class="line">辅助⼯具：python, sublime text3, postman </span><br><span class="line">源码在桌⾯ test_miniblockchain/p2p ⽂件夹内</span><br></pre></td></tr></tbody></table></figure>

<h4 id="实验步骤⼀"><a href="#实验步骤⼀" class="headerlink" title="实验步骤⼀"></a>实验步骤⼀</h4><p>任务描述：了解K桶的构造，完成K桶的构造和⼀些基本操作。</p>
<ol>
<li>在p2p⽂件夹中新建constant.py⽂件，定义bucket 的⼤⼩、bucket中节点的位数和α。</li>
</ol>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102426.png" class="lozad"></p>
<ol start="2">
<li><p>在p2p⽂件夹中新建kbucketset.py⽂件。构建Kbu cketSet类，构造函数参数包括当前节点的node_id（c urrent_node_id），k和bits。k和bits默认为常量值。 注：bucket中node ID和data key同构。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102449.png" class="lozad"></p>
</li>
<li><p>定义类的⼀些基本⽅法。 1) __is_node_in_bucket (node,bucket)，遍历K 桶，判断节点是否在K桶中。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102522.png" class="lozad"></p>
</li>
</ol>
<p>1) __is_node_in_bucket (node,bucket)，遍历K 桶，判断节点是否在K桶中。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102552.png" class="lozad"></p>
<p>2) __node_index_in_bucket (node,bucket)，找 到节点在K桶中的索引，即在K桶中的位置。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102615.png" class="lozad"></p>
<p>3) get_all_nodes()，获取所有K桶中的全部节点。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102649.png" class="lozad"></p>
<p>4) __get_distance(node_id1,node_id2)，获取两 个节点之间的异或距离。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102708.png" class="lozad"></p>
<p>5) get_bucket_number(node_id)，获取⽬标节 点相对于当前节点所在的bucket位置。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102729.png" class="lozad"></p>
<p>6) exit(node_id)，判断节点是否在路由表中。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102747.png" class="lozad"></p>
<ol start="4">
<li><p>定义类的⽅法insert(node)，往相应的bucket位置 插⼊新节点。 如果该bucket没有满且节点不重复，则插⼊到buc ket中 如果该bucket没有满且节点重复，替换该节点 如果该bucket满且节点不重复，则剔除该新节点 如果该bucket满且节点重复，替换该节点。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102815.png" class="lozad"></p>
</li>
<li><p>定义类的⽅法nearest_nodes(node_id)，获取离n ode_id节点最近的k个节点（通过最⼩堆获取）。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102843.png" class="lozad"></p>
</li>
</ol>
<h4 id="实验步骤⼆"><a href="#实验步骤⼆" class="headerlink" title="实验步骤⼆"></a>实验步骤⼆</h4><p>任务描述：更新保存距离某个节点最近的K个节点，即 维护及更新K桶。</p>
<ol>
<li>在p2p⽂件夹中新建nearestnodes.py⽂件。构建K NearestNodesUtil类，构造函数参数包括node_id、 k。k默认为常量值。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102922.png" class="lozad"></li>
</ol>
<ol start="2">
<li>定义类的⼀些基本⽅法。 1) set_target_value(value)，设置value值。</li>
</ol>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502102949.png" class="lozad"></p>
<p>3) get_unvisited_nearest_nodes(alpha)，返回al pha个最近的节点集合中还没访问的节点。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103017.png" class="lozad"></p>
<p>4) mark(visited_node)，标记已访问过的节点。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103034.png" class="lozad"></p>
<p>5) is_complete()，判断是否迭代结束。结束条 件：找到key值对应的value，或是K个节点都已访问过。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103102.png" class="lozad"></p>
<p>6) get_result_nodes()。在更新K桶节点时，要判 断⼀个新节点是否已存在，若不存在，则要保存。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103121.png" class="lozad"></p>
<ol start="3">
<li>定义类的update(nodes)⽅法，更新nearest_node s数据。获取当前node id节点跟other_node的距离， 若other_node不在nearest_nodes中，且距离更⼩， 则按距离从⼩到⼤的顺序更新nearest_nodes节点列 表，并取距离最近的前k个节点更新为k桶节点。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103146.png" class="lozad"></li>
</ol>
<h4 id="实验步骤三"><a href="#实验步骤三" class="headerlink" title="实验步骤三"></a>实验步骤三</h4><p>任务描述：完成消息接受和发送的处理。 packet.py中定义了指令请求包。</p>
<ol>
<li><p>在p2p⽂件夹中新建node.py⽂件。构建ProcessMe ssages类，⽤作服务端消息处理中⼼。 SocketServer模块提供了 BaseRequestHandler 类型⽤于定制Handler类型，⾃定义的Handler类型只 要继承⾃ BaseRequestHandler 并覆写它的 handle() ⽅法即可。 ⾸先，所有请求如下：<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103225.png" class="lozad"></p>
</li>
<li><p>构建Server类，接收消息，并做相应处理。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103300.png" class="lozad"></p>
</li>
<li><p>构建Node类，发送消息。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103321.png" class="lozad"></p>
</li>
</ol>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103347.png" class="lozad"></p>
<h4 id="实验步骤四"><a href="#实验步骤四" class="headerlink" title="实验步骤四"></a>实验步骤四</h4><p>任务描述：实现P2P⽹络，完成节点通信 </p>
<ol>
<li>构建NodeManager类，完成节点之间的相互通 信，实现kad协议算法的4种操作：Ping（检测节点是 否在线）、Store（在某个节点上存储key、value）、 Find Node（返回对⽅节点桶中距离请求key最近的k个 节点）、Finde Value（与FIND NODE类似，不过返回 的是相应key的value）。</li>
</ol>
<p>1) 构造函数参数包括ip，port，genisus_node。 genisus_node默认为False。node_id初始化为⼀个随 机数。buckets，server，client实例化。注; 每个消息 都有⼀个唯⼀的rpc_id，⽤于标识节点之间的通信（该 rpc_id由发起⽅⽣成，并由接收⽅返回），这样可以避 免节点收到多个从同⼀个节点发送的消息时⽆法区 分。</p>
<p><img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103446.png" class="lozad"></p>
<p>2) 初始化区块链。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103504.png" class="lozad"></p>
<p>3) 创建消息处理线程。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103528.png" class="lozad"></p>
<p>4) 创建矿⼯线程。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103546.png" class="lozad"></p>
<ol start="2">
<li><p>定义⼀些基本请求包。</p>
<p> 1) ping(sock, server_node_id,target_node_addr ess)<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103615.png" class="lozad"></p>
</li>
</ol>
<p>2) pong(server_node_id,target_node_addres s)，发送对ping请求的响应消息。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103633.png" class="lozad"></p>
<p>3) 其他指令同理。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103653.png" class="lozad"></p>
<p>4) <strong>hash_function(key)，返回key的哈希值； get_rpc_id()，返回⼀个128bit的随机数，；</strong>random _id()，返回⼀个[0, 2 -1]的随机数。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103744.png" class="lozad"></p>
<p>5) iterative_find_nodes(key,seed_node=Non e)，定位K个距离key最近的节点。 更新nearest_nodes节点列表，限制同时向ALPH A个邻近节点发送FIND NODE请求，返回节点集合。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103807.png" class="lozad"></p>
<p>6) iterative_find_value(key)，与上同理，返回的 是value值。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103830.png" class="lozad"></p>
<p>7) sendblock(block)，⼴播⼀个block。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103857.png" class="lozad"></p>
<p>8) sendtx(tx)，⼴播⼀个tx。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103923.png" class="lozad"></p>
<ol start="3">
<li><p>定义bootstrap()⽅法，根据初始节点引导初始 化。 与种⼦节点进⾏握⼿，然后获取与种⼦节点最近 的K个节点。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502103949.png" class="lozad"></p>
</li>
<li><p>定义minner()，实现挖矿共识。先进⾏挖矿，完成 后将新的区块⼴播，并保证连接到最⻓链。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502104014.png" class="lozad"></p>
</li>
<li><p>set_data(key, value)，存放数据。⾸先发起节点定 位K个距离key最近的节点，发起节点对这K个节点发 送STORE消息，收到STORE消息的K个节点保存(key, value)数据。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502104051.png" class="lozad"></p>
</li>
<li><p>get_data(key)，读取数据。步骤如下： 1) 当前节点收到查询数据的请求(获取key对应的v alue)； 2) 当前节点⾸先检测⾃⼰是否保存了该数据，如 果有则返回key对应的value； 3) 如果当前节点没有保存该数据，则计算获取距 离key值最近的K个节点，分别向这K个节点发送FIND VALUE的操作进⾏查询； 4) 收到FIND VALUE请求操作的节点也进⾏上述 (2)~(3)的过程（递归处理）。<img alt data-src="https://huangmgb.oss-cn-hongkong.aliyuncs.com/20200502104121.png" class="lozad"></p>
</li>
</ol>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Huang Mi Gao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/02/%E6%90%AD%E5%BB%BA%E8%BF%B7%E4%BD%A0%E5%8C%BA%E5%9D%97%E9%93%BE/">http://yoursite.com/2020/05/02/%E6%90%AD%E5%BB%BA%E8%BF%B7%E4%BD%A0%E5%8C%BA%E5%9D%97%E9%93%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">饼干🍪</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链    </a></div><div class="post_share"><div class="social-share" data-image="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588397534324&amp;di=6c1ae2cd4ad0063e9ebfe34a2babf934&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.91zhuti.com%2Fuploads%2Fallimg%2F140517%2F10-14051F95044.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05/08/%E5%AE%9E%E9%AA%8C%EF%BC%9AEFS%E7%9A%84%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86%E4%B8%8E%E7%A0%B4%E8%A7%A3/"><img class="prev_cover lozad" data-src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2766671554,1429736205&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>实验：EFS的加密、解密与破解</span></div></a></div><div class="next-post pull-right"><a href="/2020/04/30/django-url%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/"><img class="next_cover lozad" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588226522334&amp;di=0f73d3338c4ad6cc79e32e90f923cda2&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2Fcd70e2e255c0a8bf1335402890a1cdbc0b0e99bd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Django-url跳转漏洞实验剖析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/09/初识Bitcoin钱包和BitPay使用/" title="初识Bitcoin钱包和BitPay使用"><img class="relatedPosts_cover lozad"data-src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1749194184,164215891&fm=26&gp=0.jpg"><div class="relatedPosts_title">初识Bitcoin钱包和BitPay使用</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NTU3OC8yMjA4OQ=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Huang Mi Gao</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#实验步骤⼀"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">实验步骤⼀</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#实验步骤⼆"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">实验步骤⼆</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#实验步骤三"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">实验步骤三</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#实验步骤四"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">实验步骤四</span></a></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script></body></html>